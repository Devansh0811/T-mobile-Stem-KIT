import numpy as np
import math

def deg2utm(Lat, Lon):
    # Memory pre-allocation
    x = []
    y = []
    utmzone = []
    # Main Loop
    #
    la = Lat
    lo = Lon
    sa = 6378137.000000
    sb = 6356752.314245

    # e = ( ( ( sa ** 2 ) - ( sb ** 2 ) ) ** 0.5 ) / sa;
    e2 = (((sa ** 2) - (sb ** 2)) ** 0.5) / sb
    e2cuadrada = e2 ** 2
    c = (sa ** 2) / sb
    # alpha = ( sa - sb ) / sa;             #f
    # ablandamiento = 1 / alpha;   # 1/f
    lat = la * (math.pi / 180)
    lon = lo * (math.pi / 180)
    Huso = np.fix((lo / 6) + 31)
    S = ((Huso * 6) - 183)
    deltaS = lon - (S * (math.pi / 180))
    Letra = ''
    if (la < -72):
        Letra = 'C'
    elif (la < -64):
        Letra = 'D'
    elif (la < -56):
        Letra = 'E'
    elif (la < -48):
        Letra = 'F'
    elif (la < -40):
        Letra = 'G'
    elif (la < -32):
        Letra = 'H'
    elif (la < -24):
        Letra = 'J'
    elif (la < -16):
        Letra = 'K'
    elif (la < -8):
        Letra = 'L'
    elif (la < 0):
        Letra = 'M'
    elif (la < 8):
        Letra = 'N'
    elif (la < 16):
        Letra = 'P'
    elif (la < 24):
        Letra = 'Q'
    elif (la < 32):
        Letra = 'R'
    elif (la < 40):
        Letra = 'S'
    elif (la < 48):
        Letra = 'T'
    elif (la < 56):
        Letra = 'U'
    elif (la < 64):
        Letra = 'V'
    elif (la < 72):
        Letra = 'W'
    else:
        Letra = 'X'

    a = math.cos(lat) * math.sin(deltaS)
    epsilon = 0.5 * math.log((1 + a) / (1 - a))
    nu = math.atan(math.tan(lat) / math.cos(deltaS)) - lat
    v = (c / ((1 + (e2cuadrada * (math.cos(lat)) ** 2))) ** 0.5) * 0.9996
    ta = (e2cuadrada / 2) * epsilon ** 2 * (math.cos(lat)) ** 2
    a1 = math.sin(2 * lat)
    a2 = a1 * (math.cos(lat)) ** 2
    j2 = lat + (a1 / 2)
    j4 = ((3 * j2) + a2) / 4
    j6 = ((5 * j4) + (a2 * (math.cos(lat)) ** 2)) / 3
    alfa = (3 / 4) * e2cuadrada
    beta = (5 / 3) * alfa ** 2
    gama = (35 / 27) * alfa ** 3
    bm = 0.9996 * c * (lat - alfa * j2 + beta * j4 - gama * j6)
    xx = epsilon * v * (1 + (ta / 3)) + 500000
    yy = nu * v * (1 + ta) + bm
    if yy < 0:
        yy = 9999999 + yy
    x = xx
    y = yy
    utmzone = "%02d %c" % (Huso, Letra)
    return x, y, utmzone

def smoothWaypoints(wp_utm, spacing):
    la = wp_utm[0:,0]
    la = la.tolist()
    lo = wp_utm[0:,1]
    lo = lo.tolist()
    utmz = wp_utm[1,2]
    wla = [];
    wlo = [];
    u = [];
    for i in range(len(la) - 1):
        w1 = np.array([[float(la[i + 1])], [float(lo[i + 1])]])
        wi = np.array([[float(la[i])], [float(lo[i])]])
        print(w1)
        print(wi)
        v = w1 - wi;
        d = math.sqrt((la[i + 1] - la[i]) ** 2 + (lo[i + 1] - lo[i]) ** 2);
        num_points_that_fit = math.ceil(d / spacing);
        vd = (v / np.linalg.norm(v)) * spacing;
        for k in range(num_points_that_fit):
            wla.append((wi[0] + vd[0] * k));
            wlo.append((wi[1] + vd[1] * k));
            u.append(utmz);

    wla.append((la[len(la) - 1]))
    wlo.append((lo[len(lo) - 1]))
    u.append(utmz);
    return wla, wlo, u

spacingBetweenCoarseWaypoints =  0.05# 6 inches
waypoints =[]
waypoints_utm=[]
fname="waypoints.txt"
print('Loading Coarse GPS Waypoints...')
# read from local file "waypoints.txt.txt" and read into 2-D float array called: waypoints.txt
f3 = open(fname, "r")
for x in f3:
    latLong = x.split(",");
    if ("\n" in latLong[1]):
        latLong[1] = latLong[1].replace("\n", "")
    latLong = [float(i) for i in latLong]
    waypoints.append(latLong)
f3.close()

print('Converting Coarse GPS Waypoints to UTM Coordinates')
# convert all coarse gps waypoints.txt to utm coordinates
for i in range(len(waypoints)):
    [txx, tyy, tuu] = deg2utm(waypoints[i][0], waypoints[i][1])
    waypoints_utm.append([txx, tyy, tuu])

np_waypoints_utm = np.array(waypoints_utm)
print(np_waypoints_utm)
print('Smoothing UTM Waypoints...')
# smooth coarse utm waypoints.txt
[sxx, syy, suu] = smoothWaypoints(np_waypoints_utm, spacingBetweenCoarseWaypoints)